# Agent Architecture

## The Database-First AI Generation Pattern

A pattern for building AI agents that generate database-ready objects without transformation layers, ensuring type safety from database schema to AI output.

## Core Concept

**Types flow unidirectionally: Database → Models → Agents**

This eliminates the typical "AI output → transform → validate → database" pipeline by having AI generate objects in the exact format the database expects from the start.

## Architecture Layers

### 1. Database Layer (Source of Truth)

```typescript
// Database schema with AI-friendly descriptions
export const insertProjectSchema = z.object({
  title: z.string().min(1).describe('Clear, concise project title'),
  description: z.string().describe('Detailed project scope and objectives'),
  status: z
    .enum(['planning', 'active', 'completed', 'archived'])
    .describe('Current project status'),
  priority: z
    .enum(['low', 'medium', 'high'])
    .describe('Project priority level'),
  // ... more fields with descriptions
});
```

- Drizzle/Zod schemas define structure AND validation rules
- Field descriptions guide AI generation
- Single source of truth for all downstream types

### 2. Model Layer (Data Operations)

```typescript
// Models provide typed CRUD operations
export async function getProjects(params: { ids?: string[] }) {
  return db.query.projects.findMany({
    where: params.ids ? inArray(projects.id, params.ids) : undefined,
    with: { tags: true }, // Include relations
  });
}

export async function createProjects(data: InsertProject | InsertProject[]) {
  // Direct insert - data already matches schema
  const items = Array.isArray(data) ? data : [data];
  return db.insert(projects).values(items).returning();
}
```

- Handles database transactions
- Manages relationships and joins
- Return types become TPersisted in agents

### 3. Agent Layer (AI Generation)

```typescript
class ProjectGeneratorAgent extends BaseAgent<...> {
  // AI output schema derived directly from database schema
  static readonly OUTPUT_SCHEMA = z.discriminatedUnion('type', [
    z.object({
      type: z.literal('existing'),
      id: z.string()
    }),
    z.object({
      type: z.literal('new'),
      project: insertProjectSchema  // Direct database schema usage
    })
  ]);

  async execute() {
    // Searches existing or generates new
    // Returns data, does NOT persist
    return this.result; // { type: 'new', project: {...} } or { type: 'existing', id: '...' }
  }
}

// Actions/scripts handle persistence:
const agent = await ProjectGeneratorAgent.generate([...]);
const result = agent.getResult();

if (result.type === 'existing') {
  // Fetch existing record via model
  const projects = await getProjects({ ids: [result.id] });
} else {
  // Create via model layer
  const created = await createProjects([result.project]);
}
```

## Design Principles

### 1. Zero-Transformation Pipeline

- AI generates objects matching exact database insert format
- No mapping, conversion, or transformation layers needed
- Database schemas ARE the AI output schemas

### 2. Discriminated Union Pattern

```typescript
type AgentResult =
  | { type: 'existing'; id: string } // Found via search
  | { type: 'new'; data: InsertSchema }; // Generated by AI
```

- Enables find-or-create workflows
- Type-safe handling of both cases
- Defers persistence decision

### 3. Generation-Only Pattern

**Agent Responsibilities:**

- Search/read existing database records
- Generate new data structures via AI
- Return database-ready objects
- NO create/update/delete operations

**Persistence Responsibilities (Actions/Scripts):**

- Call agent to generate data
- Review/validate agent output
- Delegate to model layer for persistence
- Handle transactions and relations

### 4. Self-Contained Tools

Each agent defines its tools inline for:

- Token efficiency (minimal search results)
- Type safety (tools match schemas)
- Encapsulation (no external dependencies)

```typescript
static readonly TOOLS = {
  searchProjects: {
    description: "Search existing projects",
    inputSchema: z.object({ query: z.string() }),
    execute: async ({ query }) => {
      // Return minimal data for token efficiency
      return db.select({ id: projects.id, title: projects.title })
        .from(projects)
        .where(like(projects.title, `%${query}%`));
    }
  }
};
```

## Implementation Checklist

1. **Database Schema**
   - [ ] Define Zod schemas with AI-friendly descriptions
   - [ ] Export insert and select schemas
   - [ ] Include all validation rules

2. **Model Layer**
   - [ ] Create typed CRUD functions
   - [ ] Handle relationships/joins
   - [ ] Return consistent shapes

3. **Agent Class**
   - [ ] Import database schemas directly
   - [ ] Define discriminated union output
   - [ ] Implement search tools
   - [ ] Zero-transformation persist()

## Benefits

- **Type Safety**: Database constraints enforced at generation time
- **No Drift**: Schema changes automatically flow to AI
- **Efficiency**: No redundant validation or transformation
- **Flexibility**: Defer persistence for batching or user review
- **Maintainability**: Single source of truth for all types

## Example: Complete Flow

```typescript
// In a server action:
export async function generateAndCreateProject(
  description: string,
  teamId: string,
) {
  try {
    // 1. Agent generates data
    const agent = await ProjectGeneratorAgent.generate([
      { role: 'user', content: description },
    ]);

    const result = agent.getResult();
    // { type: 'new', project: { title: 'Website Redesign', description: '...', ... } }

    // 2. Optional: Validate/modify in action
    // if (result.type === 'new') {
    //   result.project.priority = 'high';
    // }

    // 3. Action delegates persistence to model
    if (result.type === 'existing') {
      const projects = await getProjects({ ids: [result.id] });
      return { success: true, data: projects[0] };
    } else {
      const created = await createProjects([{ ...result.project, teamId }]);
      return { success: true, data: created[0] };
    }
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

// Batch example - multiple agents, single model call:
const agents = await Promise.all([
  TaskGeneratorAgent.generate([{ role: 'user', content: 'implement auth' }]),
  TaskGeneratorAgent.generate([{ role: 'user', content: 'write tests' }]),
  TaskGeneratorAgent.generate([{ role: 'user', content: 'update docs' }]),
]);

const newTasks = agents
  .map((a) => a.getResult())
  .filter((r) => r.type === 'new')
  .map((r) => ({ ...r.task, projectId: 'proj-123' }));

const created = await createTasks(newTasks); // Bulk insert via model
```
